{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Pydantic-ish way to manage your project's YAML configurations. Documentation : https://dribia.github.io/driconfig Source Code : https://github.com/dribia/driconfig The usage of YAML files to store configurations and parameters is widely accepted in the Python community, especially in Data Science environments. DriConfig provides a clean interface between your Python code and these YAML configuration files. It is heavily based on Pydantic 's Settings Management , preserving its core functionalities and advantages. Key features \ud83d\udd17 Subclassing the DriConfig class we create an interface to any YAML configuration file . Our project's configurations are then attributes of this class. They are automatically filled with the values in the YAML configuration file. We can define complex configuration structures using Pydantic models. We preserve Pydantic's type casting and validation ! Example \ud83d\udd17 Let's say we have a YAML configuration file config.yaml with the following data: # config.yaml model_parameters : eta : 0.2 gamma : 2 lambda : 1 date_interval : start : 2021-01-01 end : 2021-12-31 Then we can parse with driconfig as follows: from datetime import date from typing import Dict from driconfig import DriConfig from pydantic import BaseModel class DateInterval ( BaseModel ): \"\"\"Model for the `date_interval` configuration.\"\"\" start : date end : date class AppConfig ( DriConfig ): \"\"\"Interface for the config/config.yaml file.\"\"\" class Config : \"\"\"Configure the YAML file location.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" model_parameters : Dict [ str , float ] date_interval : DateInterval config = AppConfig () print ( config . json ( indent = 4 )) \"\"\" { \"model_parameters\": { \"eta\": 0.2, \"gamma\": 2.0, \"lambda\": 1.0 }, \"date_interval\": { \"start\": \"2021-01-01\", \"end\": \"2021-12-31\" } } \"\"\"","title":"driconfig"},{"location":"#key-features","text":"Subclassing the DriConfig class we create an interface to any YAML configuration file . Our project's configurations are then attributes of this class. They are automatically filled with the values in the YAML configuration file. We can define complex configuration structures using Pydantic models. We preserve Pydantic's type casting and validation !","title":"Key features"},{"location":"#example","text":"Let's say we have a YAML configuration file config.yaml with the following data: # config.yaml model_parameters : eta : 0.2 gamma : 2 lambda : 1 date_interval : start : 2021-01-01 end : 2021-12-31 Then we can parse with driconfig as follows: from datetime import date from typing import Dict from driconfig import DriConfig from pydantic import BaseModel class DateInterval ( BaseModel ): \"\"\"Model for the `date_interval` configuration.\"\"\" start : date end : date class AppConfig ( DriConfig ): \"\"\"Interface for the config/config.yaml file.\"\"\" class Config : \"\"\"Configure the YAML file location.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" model_parameters : Dict [ str , float ] date_interval : DateInterval config = AppConfig () print ( config . json ( indent = 4 )) \"\"\" { \"model_parameters\": { \"eta\": 0.2, \"gamma\": 2.0, \"lambda\": 1.0 }, \"date_interval\": { \"start\": \"2021-01-01\", \"end\": \"2021-12-31\" } } \"\"\"","title":"Example"},{"location":"contribute/","text":"Contribute \ud83d\udd17 Contributions to Dribia libraries are always welcome! Mantainers \ud83d\udd17 Driconfig is maintained by: Irene P\u00e9rez - irene@dribia.com Albert Iribarne - iribarne@dribia.com Issues \ud83d\udd17 Questions, feature requests and bug reports are all welcome as discussions or issues . Please note which version of the library are you using whenever reporting a bug. python -c \"import driconfig; print(driconfig.__version__)\" It would be very useful too to know which OS and Python version are your running driconfig from. Contribute \ud83d\udd17 In order to contribute, the first step is to clone yourself the code: repository : git clone https://github.com/dribia/driconfig.git Then, you can step into the project's root and, assuming that you have both Poetry and pre-commit installed, run: poetry install && pre-commit install Now you should be ready to start coding and prepare your pull request . Remember that you can run linting and tests locally with: sh scripts/lint.sh sh scripts/test.sh Happy coding!","title":"Contribute"},{"location":"contribute/#contribute","text":"Contributions to Dribia libraries are always welcome!","title":"Contribute"},{"location":"contribute/#mantainers","text":"Driconfig is maintained by: Irene P\u00e9rez - irene@dribia.com Albert Iribarne - iribarne@dribia.com","title":"Mantainers"},{"location":"contribute/#issues","text":"Questions, feature requests and bug reports are all welcome as discussions or issues . Please note which version of the library are you using whenever reporting a bug. python -c \"import driconfig; print(driconfig.__version__)\" It would be very useful too to know which OS and Python version are your running driconfig from.","title":"Issues"},{"location":"contribute/#contribute_1","text":"In order to contribute, the first step is to clone yourself the code: repository : git clone https://github.com/dribia/driconfig.git Then, you can step into the project's root and, assuming that you have both Poetry and pre-commit installed, run: poetry install && pre-commit install Now you should be ready to start coding and prepare your pull request . Remember that you can run linting and tests locally with: sh scripts/lint.sh sh scripts/test.sh Happy coding!","title":"Contribute"},{"location":"install/","text":"PIP \ud83d\udd17 Installation is as simple as: pip install driconfig Driconfig heavily depends on two other Python libraries, that will be installed as dependencies: Pydantic is a data validation framework using Python type annotations. PyYAML is a full-featured YAML framework for the Python programming language.","title":"Install"},{"location":"install/#pip","text":"Installation is as simple as: pip install driconfig Driconfig heavily depends on two other Python libraries, that will be installed as dependencies: Pydantic is a data validation framework using Python type annotations. PyYAML is a full-featured YAML framework for the Python programming language.","title":"PIP"},{"location":"usage/config/","text":"Pydantic's Config class \ud83d\udd17 A Pydantic model's internal Config class controls many aspects of its functionality. An exhaustive list can be found in Pydantic's documentation . The DriConfig class, as it inherits from Pydantic's BaseModel , has all these configuration options available. However, we have added some new configuration options, and modified some of its defaults. DriConfig's Config class. \ud83d\udd17 New configurations \ud83d\udd17 Field Type (default) Description config_folder str ( \"config\" ) Path to the folder where the YAML file is placed. config_file_name str ( \"config.yaml\" ) YAML file name. config_file_encoding Optional[str] ( None ) YAML file encoding. If None , the PyYAML default is used. config_prefix str ( \"\" ) Prefix for configuration variable names. case_sensitive bool ( False ) Whether to be case sensitive when reading variables from the YAML configuration file. Tip The config_prefix is useful when working with environments, so that configurations can be named e.g. after DEV_ , PRE_ or PRO_ prefixes, but accessed with their root names within the code. Note that the prefix only affects first-level names in the YAML file. Names in nested configurations should not be prefixed. # config.yaml PRE_PARENT_CONFIG : CHILD_CONFIG_A : 1 CHILD_CONFIG_B : 1.2 # main.py from typing import Dict from driconfig import DriConfig class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" config_prefix = \"PRE_\" PARENT_CONFIG : Dict [ str , float ] app_config = AppConfig () print ( app_config . json ( indent = 4 )) \"\"\" { \"PARENT_CONFIG\": { \"CHILD_CONFIG_A\": 1.0, \"CHILD_CONFIG_B\": 1.2 } } \"\"\" Modified configurations \ud83d\udd17 Field Type (default) Description validate_all bool ( True ) Defaults to True so that validation is done in YAML file parsing. arbitrary_types_allowed bool ( True ) Allow arbitrary types by default. extra str ( forbid ) Forbid extra arguments on initialization by default.","title":"Config"},{"location":"usage/config/#pydantics-config-class","text":"A Pydantic model's internal Config class controls many aspects of its functionality. An exhaustive list can be found in Pydantic's documentation . The DriConfig class, as it inherits from Pydantic's BaseModel , has all these configuration options available. However, we have added some new configuration options, and modified some of its defaults.","title":"Pydantic's Config class"},{"location":"usage/config/#driconfigs-config-class","text":"","title":"DriConfig's Config class."},{"location":"usage/config/#new-configurations","text":"Field Type (default) Description config_folder str ( \"config\" ) Path to the folder where the YAML file is placed. config_file_name str ( \"config.yaml\" ) YAML file name. config_file_encoding Optional[str] ( None ) YAML file encoding. If None , the PyYAML default is used. config_prefix str ( \"\" ) Prefix for configuration variable names. case_sensitive bool ( False ) Whether to be case sensitive when reading variables from the YAML configuration file. Tip The config_prefix is useful when working with environments, so that configurations can be named e.g. after DEV_ , PRE_ or PRO_ prefixes, but accessed with their root names within the code. Note that the prefix only affects first-level names in the YAML file. Names in nested configurations should not be prefixed. # config.yaml PRE_PARENT_CONFIG : CHILD_CONFIG_A : 1 CHILD_CONFIG_B : 1.2 # main.py from typing import Dict from driconfig import DriConfig class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" config_prefix = \"PRE_\" PARENT_CONFIG : Dict [ str , float ] app_config = AppConfig () print ( app_config . json ( indent = 4 )) \"\"\" { \"PARENT_CONFIG\": { \"CHILD_CONFIG_A\": 1.0, \"CHILD_CONFIG_B\": 1.2 } } \"\"\"","title":"New configurations"},{"location":"usage/config/#modified-configurations","text":"Field Type (default) Description validate_all bool ( True ) Defaults to True so that validation is done in YAML file parsing. arbitrary_types_allowed bool ( True ) Allow arbitrary types by default. extra str ( forbid ) Forbid extra arguments on initialization by default.","title":"Modified configurations"},{"location":"usage/intro/","text":"Driconfig mimics Pydantic's Settings Management functionality, working with YAML configurations instead of environment variables or .env files. The YAML language \ud83d\udd17 YAML is a human-readable data-serialization language, commonly used for configuration files. It natively encodes scalars (such as strings, integers, and floats), lists, and dictionaries. # config.yaml parameter_a : \"some string\" parameter_b : 1 parameter_c : 1.2 parameter_d : [ \"I'm\" , \"a\" , \"list\" ] The above code block contains a sample configuration file written in the YAML language. Info If you want to run the rest of the code blocks in this document, place the contents of the previous one into a file called config.yaml in your working directory. Tip A YAML configuration file should always be a dictionary at its first level. The elements of this dictionary, then, could be of any type (scalars, lists or dictionaries). The goal of Driconfig is to provide an interface between your Python code and such YAML confguration files. The DriConfig class \ud83d\udd17 Driconfig provides a base configuration class called DriConfig . This base class should be sub-classed in order to generate custom configuration classes that represent YAML configuration files. from driconfig import DriConfig class AppConfig ( DriConfig ): # Inherits the base DriConfig class. \"\"\"Empty configuration class.\"\"\" pass app_config = AppConfig () print ( app_config . json ()) \"\"\" {} \"\"\" The DriConfig's Config class \ud83d\udd17 Now, we would want to read and parse the config.yaml file we created before. We need to configure our AppConfig class in order to point at that file. from driconfig import DriConfig class AppConfig ( DriConfig ): \"\"\"Empty configuration class.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" app_config = AppConfig () print ( app_config . json ()) \"\"\" {} \"\"\" Note We have extended the use of Pydantic models Config class to host the YAML file information. In the Config section we detail which configurations have been added or modified. Parsing YAML configurations \ud83d\udd17 Now we would want to parse the configurations we put on our config.yaml file. from typing import List from driconfig import DriConfig class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" parameter_a : str parameter_b : int parameter_c : float parameter_d : List [ str ] app_config = AppConfig () print ( app_config . json ( indent = 4 )) \"\"\" { \"parameter_a\": \"some string\", \"parameter_b\": 1, \"parameter_c\": 1.2, \"parameter_d\": [ \"I'm\", \"a\", \"list\" ] } \"\"\" Note how we declared the configuration variable types following Pydantic's syntax. In fact, while parsing the config.yaml file Driconfig is performing type validation , so that if your configuration variable value is of an undesired type it will raise a validation error. from driconfig import DriConfig from pydantic import ValidationError class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" parameter_a : int try : app_config = AppConfig () except ValidationError as e : print ( e ) \"\"\" 1 validation error for AppConfig parameter_a value is not a valid integer (type=type_error.integer) \"\"\" As you can guess, all the benefits from Pydantic are hold by the DriConfig base class. Then, apart from raising errors on incorrect types, values are casted to the correct type when possible, and even nested configurations can be expressed as nested Pydantic models. In particular, also the default values behavior is preserved from Pydantic. This is, we could define a default value for a given configuration, so that if the configuration is not present in the YAML configuration file, it gets the default value from the configuration class definition. from typing import List from driconfig import DriConfig class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" parameter_a : str parameter_b : int parameter_c : float parameter_d : List [ str ] parameter_e : str = \"default value\" app_config = AppConfig () print ( app_config . json ( indent = 4 )) \"\"\" { \"parameter_a\": \"some string\", \"parameter_b\": 1, \"parameter_c\": 1.2, \"parameter_d\": [ \"I'm\", \"a\", \"list\" ], \"parameter_e\": \"default_value } \"\"\" Now, if we add parameter_e to our config.yaml file: # config.yaml parameter_a : \"some string\" parameter_b : 1 parameter_c : 1.2 parameter_d : [ \"I'm\" , \"a\" , \"list\" ] parameter_e : \"custom value\" We see how it prevails over the default value: from typing import List from driconfig import DriConfig class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" parameter_a : str parameter_b : int parameter_c : float parameter_d : List [ str ] parameter_e : str = \"default value\" app_config = AppConfig () print ( app_config . json ( indent = 4 )) \"\"\" { \"parameter_a\": \"some string\", \"parameter_b\": 1, \"parameter_c\": 1.2, \"parameter_d\": [ \"I'm\", \"a\", \"list\" ], \"parameter_e\": \"custom value\" } \"\"\"","title":"Intro"},{"location":"usage/intro/#the-yaml-language","text":"YAML is a human-readable data-serialization language, commonly used for configuration files. It natively encodes scalars (such as strings, integers, and floats), lists, and dictionaries. # config.yaml parameter_a : \"some string\" parameter_b : 1 parameter_c : 1.2 parameter_d : [ \"I'm\" , \"a\" , \"list\" ] The above code block contains a sample configuration file written in the YAML language. Info If you want to run the rest of the code blocks in this document, place the contents of the previous one into a file called config.yaml in your working directory. Tip A YAML configuration file should always be a dictionary at its first level. The elements of this dictionary, then, could be of any type (scalars, lists or dictionaries). The goal of Driconfig is to provide an interface between your Python code and such YAML confguration files.","title":"The YAML language"},{"location":"usage/intro/#the-driconfig-class","text":"Driconfig provides a base configuration class called DriConfig . This base class should be sub-classed in order to generate custom configuration classes that represent YAML configuration files. from driconfig import DriConfig class AppConfig ( DriConfig ): # Inherits the base DriConfig class. \"\"\"Empty configuration class.\"\"\" pass app_config = AppConfig () print ( app_config . json ()) \"\"\" {} \"\"\"","title":"The DriConfig class"},{"location":"usage/intro/#the-driconfigs-config-class","text":"Now, we would want to read and parse the config.yaml file we created before. We need to configure our AppConfig class in order to point at that file. from driconfig import DriConfig class AppConfig ( DriConfig ): \"\"\"Empty configuration class.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" app_config = AppConfig () print ( app_config . json ()) \"\"\" {} \"\"\" Note We have extended the use of Pydantic models Config class to host the YAML file information. In the Config section we detail which configurations have been added or modified.","title":"The DriConfig's Config class"},{"location":"usage/intro/#parsing-yaml-configurations","text":"Now we would want to parse the configurations we put on our config.yaml file. from typing import List from driconfig import DriConfig class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" parameter_a : str parameter_b : int parameter_c : float parameter_d : List [ str ] app_config = AppConfig () print ( app_config . json ( indent = 4 )) \"\"\" { \"parameter_a\": \"some string\", \"parameter_b\": 1, \"parameter_c\": 1.2, \"parameter_d\": [ \"I'm\", \"a\", \"list\" ] } \"\"\" Note how we declared the configuration variable types following Pydantic's syntax. In fact, while parsing the config.yaml file Driconfig is performing type validation , so that if your configuration variable value is of an undesired type it will raise a validation error. from driconfig import DriConfig from pydantic import ValidationError class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" parameter_a : int try : app_config = AppConfig () except ValidationError as e : print ( e ) \"\"\" 1 validation error for AppConfig parameter_a value is not a valid integer (type=type_error.integer) \"\"\" As you can guess, all the benefits from Pydantic are hold by the DriConfig base class. Then, apart from raising errors on incorrect types, values are casted to the correct type when possible, and even nested configurations can be expressed as nested Pydantic models. In particular, also the default values behavior is preserved from Pydantic. This is, we could define a default value for a given configuration, so that if the configuration is not present in the YAML configuration file, it gets the default value from the configuration class definition. from typing import List from driconfig import DriConfig class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" parameter_a : str parameter_b : int parameter_c : float parameter_d : List [ str ] parameter_e : str = \"default value\" app_config = AppConfig () print ( app_config . json ( indent = 4 )) \"\"\" { \"parameter_a\": \"some string\", \"parameter_b\": 1, \"parameter_c\": 1.2, \"parameter_d\": [ \"I'm\", \"a\", \"list\" ], \"parameter_e\": \"default_value } \"\"\" Now, if we add parameter_e to our config.yaml file: # config.yaml parameter_a : \"some string\" parameter_b : 1 parameter_c : 1.2 parameter_d : [ \"I'm\" , \"a\" , \"list\" ] parameter_e : \"custom value\" We see how it prevails over the default value: from typing import List from driconfig import DriConfig class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" parameter_a : str parameter_b : int parameter_c : float parameter_d : List [ str ] parameter_e : str = \"default value\" app_config = AppConfig () print ( app_config . json ( indent = 4 )) \"\"\" { \"parameter_a\": \"some string\", \"parameter_b\": 1, \"parameter_c\": 1.2, \"parameter_d\": [ \"I'm\", \"a\", \"list\" ], \"parameter_e\": \"custom value\" } \"\"\"","title":"Parsing YAML configurations"},{"location":"usage/nested_models/","text":"Being able to use Pydantic models to parse nested configurations on our YAML files is maybe the strongest point of Driconfig. Let's say we have a YAML config.yaml file looking like this: # config.yaml timeout : 1000 min_date : 2021-04-17 model_parameters : alpha : 2 beta : 0.1 gamma : 30 In this case, model_parameters is what we call a nested configuration , being a dictionary of dictionaries . Then, we would have two options: Parse model_parameters as a dict type. Parse it as a Pydantic model, and performing specific type validation for each of its values. Arbitrary types \ud83d\udd17 Let's parse the model_parameters configuration as an arbitrary dictionary. from datetime import date from typing import Any , Dict from driconfig import DriConfig class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" timeout : int min_date : date model_parameters : Dict [ str , Any ] app_config = AppConfig () print ( app_config . json ( indent = 4 )) \"\"\" { \"timeout\": 1000, \"min_date\": \"2021-04-17\", \"model_parameters\": { \"alpha\": 2, \"beta\": 0.1, \"gamma\": 30 } } \"\"\" print ( type ( app_config . model_parameters )) \"\"\" <class 'dict'> \"\"\" Note that no type validation is performed on the values of model_paramters . Instead, it is stored as an arbitrary dictionary. Nested model \ud83d\udd17 Now, let's properly parse model_parameters as a Pydantic model. from datetime import date from pydantic import BaseModel from driconfig import DriConfig class ModelParameters ( BaseModel ): \"\"\"Pydantic model for `model_parameters`.\"\"\" alpha : int beta : float gamma : int class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" timeout : int min_date : date model_parameters : ModelParameters app_config = AppConfig () print ( app_config . json ( indent = 4 )) \"\"\" { \"timeout\": 1000, \"min_date\": \"2021-04-17\", \"model_parameters\": { \"alpha\": 2, \"beta\": 0.1, \"gamma\": 30 } } \"\"\" print ( type ( app_config . model_parameters )) \"\"\" <class '__main__.ModelParameters'> \"\"\" Note how, in this case, type validation is performed for alpha , beta and gamma . We could mimic this pattern to build even deeper nested configuration parsers, holding all of Pydantic's validation power.","title":"Nested models"},{"location":"usage/nested_models/#arbitrary-types","text":"Let's parse the model_parameters configuration as an arbitrary dictionary. from datetime import date from typing import Any , Dict from driconfig import DriConfig class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" timeout : int min_date : date model_parameters : Dict [ str , Any ] app_config = AppConfig () print ( app_config . json ( indent = 4 )) \"\"\" { \"timeout\": 1000, \"min_date\": \"2021-04-17\", \"model_parameters\": { \"alpha\": 2, \"beta\": 0.1, \"gamma\": 30 } } \"\"\" print ( type ( app_config . model_parameters )) \"\"\" <class 'dict'> \"\"\" Note that no type validation is performed on the values of model_paramters . Instead, it is stored as an arbitrary dictionary.","title":"Arbitrary types"},{"location":"usage/nested_models/#nested-model","text":"Now, let's properly parse model_parameters as a Pydantic model. from datetime import date from pydantic import BaseModel from driconfig import DriConfig class ModelParameters ( BaseModel ): \"\"\"Pydantic model for `model_parameters`.\"\"\" alpha : int beta : float gamma : int class AppConfig ( DriConfig ): \"\"\"Configuration class to parse the config.yaml file contents.\"\"\" class Config : \"\"\"Configure AppConfig to point at the config.yaml file.\"\"\" config_folder = \".\" config_file_name = \"config.yaml\" timeout : int min_date : date model_parameters : ModelParameters app_config = AppConfig () print ( app_config . json ( indent = 4 )) \"\"\" { \"timeout\": 1000, \"min_date\": \"2021-04-17\", \"model_parameters\": { \"alpha\": 2, \"beta\": 0.1, \"gamma\": 30 } } \"\"\" print ( type ( app_config . model_parameters )) \"\"\" <class '__main__.ModelParameters'> \"\"\" Note how, in this case, type validation is performed for alpha , beta and gamma . We could mimic this pattern to build even deeper nested configuration parsers, holding all of Pydantic's validation power.","title":"Nested model"}]}